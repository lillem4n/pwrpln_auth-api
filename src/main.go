package main

import (
	"context"
	"os"
	"strings"
	"time"

	"gitea.larvit.se/pwrpln/auth-api/src/db"
	h "gitea.larvit.se/pwrpln/auth-api/src/handlers"
	"gitea.larvit.se/pwrpln/go_log"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/swagger"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"
	pgxUuid "github.com/vgarvardt/pgx-google-uuid/v5"

	// docs are generated by Swag CLI, you have to import them.
	"gitea.larvit.se/pwrpln/auth-api/src/docs"
)

// Don't put in utils, because it creates import cycle with db... just left it here for now
func createAdminAccount(Db db.Db, log go_log.Log, ADMIN_API_KEY string) {
	adminAccountID, uuidErr := uuid.NewRandom()
	if uuidErr != nil {
		log.Error("Could not create new Uuid", "err", uuidErr.Error())
		os.Exit(1)
	}
	_, adminAccountErr := Db.AccountCreate(db.AccountCreateInput{
		ID:       adminAccountID,
		Name:     "admin",
		APIKey:   ADMIN_API_KEY,
		Password: "",
		Fields:   []db.AccountCreateInputFields{{Name: "role", Values: []string{"admin"}}},
	})
	if adminAccountErr != nil && strings.HasPrefix(adminAccountErr.Error(), "ERROR: duplicate key") {
		log.Verbose("Admin account already created, nothing written to database")
	} else if adminAccountErr != nil {
		log.Error("Could not create admin account", "err", adminAccountErr.Error())
		os.Exit(1)
	}
}

// @title JWT Auth API
// @description This is a tiny http API for auth. Register accounts, auth with api-key or name/password, renew JWT tokens...

// @contact.name Power Plan
// @contact.url https://pwrpln.com/
// @contact.email lilleman@larvit.se

// @license.name MIT
func main() {
	err := godotenv.Load(".env")
	if err != nil {
		tmpLog := go_log.GetLog()
		tmpLog.Info("No .env file found")
	}

	log := go_log.GetLog()

	if os.Getenv("JWT_SHARED_SECRET") == "changeMe" {
		log.Warn("JWT_SHARED_SECRET ENV is not set, using very insecure \"changeMe\"")
	}
	if os.Getenv("ADMIN_API_KEY") == "changeMe" {
		log.Warn("ADMIN_API_KEY ENV is not set, using very insecure \"changeMe\"")
	}
	if os.Getenv("LOG_MIN_LVL") == "" {
		log.Info("LOG_MIN_LVL ENV is not set, using default \"Info\"")
		log.MinLogLvl = go_log.LogLvlFromStr("Info")
	} else {
		minLogLvl := go_log.LogLvlFromStr(os.Getenv("LOG_MIN_LVL"))

		if minLogLvl == 0 {
			log.Warn("Invalid LOG_MIN_LVL ENV, using default \"Info\"")
			log.MinLogLvl = go_log.LogLvlFromStr("Info")
		} else {
			log.MinLogLvl = minLogLvl
		}
	}

	ADMIN_API_KEY := os.Getenv("ADMIN_API_KEY")
	DATABASE_URL := os.Getenv("DATABASE_URL")
	PUBLIC_HOST := os.Getenv("PUBLIC_HOST")
	URL_PREFIX := os.Getenv("URL_PREFIX")
	WEB_BIND_HOST := os.Getenv("WEB_BIND_HOST")

	if URL_PREFIX == "" {
		URL_PREFIX = "/"
	}

	docs.SwaggerInfo.Version = "0.3.9"
	docs.SwaggerInfo.Host = PUBLIC_HOST
	docs.SwaggerInfo.BasePath = URL_PREFIX

	jwtKey := []byte(os.Getenv("JWT_SHARED_SECRET"))

	pgxConfig, err := pgxpool.ParseConfig(DATABASE_URL)
	if err != nil {
		log.Error("Failed to create pgxConfig", "err", err.Error())
		os.Exit(1)
	}

	pgxConfig.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error {
		pgxUuid.Register(conn.TypeMap())
		return nil
	}

	dbPool, err := pgxpool.NewWithConfig(context.TODO(), pgxConfig)
	if err != nil {
		log.Warn("Failed to open connection to PostgreSQL database, retrying in 1 second", "err", err.Error())
		time.Sleep(1 * time.Second)
		dbPool, err = pgxpool.NewWithConfig(context.TODO(), pgxConfig)
	}
	log.Verbose("Connected to PostgreSQL database")
	defer dbPool.Close()

	app := fiber.New()

	Db := db.Db{DbPool: dbPool, Log: log}
	handlers := h.Handlers{Db: Db, JwtKey: jwtKey, Log: log}

	createAdminAccount(Db, log, ADMIN_API_KEY)

	// Log all requests
	app.Use(handlers.LogReq)

	// Always require application/json
	app.Use(handlers.RequireJSON)

	app.Get(URL_PREFIX, func(c *fiber.Ctx) error { return c.Redirect(URL_PREFIX + "swagger/index.html") })
	app.Get(URL_PREFIX+"swagger", func(c *fiber.Ctx) error { return c.Redirect(URL_PREFIX + "swagger/index.html") })
	app.Get(URL_PREFIX+"swagger/*", swagger.HandlerDefault)

	app.Delete(URL_PREFIX+"accounts/:accountID", handlers.AccountDel)
	app.Get(URL_PREFIX+"accounts/:accountID", handlers.AccountGet)
	app.Post(URL_PREFIX+"accounts", handlers.AccountCreate)
	app.Get(URL_PREFIX+"accounts", handlers.AccountsGet)
	app.Post(URL_PREFIX+"auth/api-key", handlers.AccountAuthAPIKey)
	app.Post(URL_PREFIX+"auth/password", handlers.AccountAuthPassword)
	app.Post(URL_PREFIX+"renew-token", handlers.RenewToken)
	app.Put(URL_PREFIX+"accounts/:accountID/fields", handlers.AccountUpdateFields)

	log.Info("Starting web server", "WEB_BIND_HOST", WEB_BIND_HOST)

	err = app.Listen(WEB_BIND_HOST)
	for err != nil {
		log.Warn("Could not start web server", "err", err.Error(), "WEB_BIND_HOST", WEB_BIND_HOST)
		time.Sleep(1 * time.Second)
		err = app.Listen(WEB_BIND_HOST)
	}

	log.Info("Web server closed, shutting down")
}
